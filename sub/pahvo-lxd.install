#!/bin/bash
#
# write by Aguy

_echoT "\n==========================================  ${S_RELEASE_NAME}-${_PART}"

########################  REQUIRED

file_completion_conf=${S_PATH_INSTALL_CONF}/bash-completion/lxc.1804
file_rsyslog_cron=${path_install_server}/rsyslog/cron.conf
file_rsyslog_client_auth=${path_install_server}/rsyslog/client-auth.conf
file_logrotate_server=${path_install_server}/logrotate/client-server

path_install_server=/home/shared/dev/install/conf

_echoT "----------  required files"

_require ${file_completion_conf} ${file_rsyslog_cron} ${file_rsyslog_client_auth} ${file_logrotate_server}


########################  DATA

_echoT "----------  data"

[ -z ${_LXD_DHCP_MIN+x} ] && anstmp="20" && _askno "Give minimal range IP for DHCP container (${anstmp})" && _LXD_DHCP_MIN="${_ANSWER:-$anstmp}" && _confset _LXD_DHCP_MIN "${_LXD_DHCP_MIN}"
[ -z ${_LXD_DHCP_MAX+x} ] && anstmp="254" && _askno "Give maximal range IP for DHCP container (${anstmp})" && _LXD_DHCP_MAX="${_ANSWER:-$anstmp}" && _confset _LXD_DHCP_MAX "${_LXD_DHCP_MAX}"

# root path of lxd
_LXD_PATH_ROOT=/var/snap/lxd/common/lxd && _confset _LXD_PATH_ROOT "${_LXD_PATH_ROOT}"
# root path of storage pools for
_LXD_PATH_SP=storage-pools && _confset _LXD_PATH_SP "${_LXD_PATH_SP}"
# path for containers
_LXD_PATH_CT=containers && _confset _LXD_PATH_CT "${_LXD_PATH_CT}"
# path for containers images
_LXD_PATH_IMAGE=images && _confset _LXD_PATH_IMAGE "${_LXD_PATH_IMAGE}"
# path for containers snapshots
_LXD_PATH_SNAPSHOT=snapshots && _confset _LXD_PATH_SNAPSHOT "${_LXD_PATH_SNAPSHOT}"
# path for export
_LXD_PATH_EXPORT=export && _confset _LXD_PATH_EXPORT "${_LXD_PATH_EXPORT}"
# port for remote connection
_LXD_PORT=8443 && _confset _LXD_PORT "${_LXD_PORT}"


########################  PATH

paths="${S_HOST_PATH} ${S_HOST_PATH_SP} ${S_HOST_PATH_SHARE} ${S_HOST_PATH_LOG} ${S_HOST_PATH_SAVE}"
_echoT "----------  create ${paths}"
for path in ${paths}; do
	[ -d "${path}" ] || _evalqr mkdir -p ${path}
done

########################  INSTALL

_echoT "----------  install"
_eval yay --noconfirm -S jq snapd
_evalr systemctl enable --now snapd
export PATH="${PATH}:/var/lib/snapd/snap/bin"
sleep 1

_echoT "----------  snap lxd"
_evalr snap install lxd
sleep 1
_evalr snap refresh

_echoT "----------  activate lxd"
systemctl is-active
systemctl is-active snap.lxd.daemon|grep -q ^inactive && _service start snap.lxd.daemon

_echoT "----------  add user"
_evalr usermod -a -G lxd ${USER}

_echoT "----------  bash completion"
path=/usr/share/bash-completion/completions
file=${path}/lxc
_keepmvts ${file}
_evalr ln -s  ${file_completion_conf} ${file}


########################  RIGHTS

_echoT "----------  link ${_LXD_PATH_ROOT} to /lxd"

link=/lxd
[ -h ${link} ] || _evalr ln -s ${_LXD_PATH_ROOT} ${link}

path=${S_HOST_PATH_SHARE}
_echoT "----------  rights ${path}"
[ "${S_STORAGE_DRIVER}" = zfs ] && id=1000000 || id=100000
_evalr setfacl -Rm u:${id}:rwx ${path}
_evalr setfacl -Rm d:u:${id}:rwx ${path}
_evalr chown ${id}:${id} -R "${path}"


########################  CLEAN STORAGE

if [ "${S_STORAGE_DRIVER}" = zfs ]; then
	for path in `_evalr zfs list -d 1 -o name -H ${_ZFS_ROOT}${S_HOST_PATH_SP}|grep -v ^${_ZFS_ROOT}${S_HOST_PATH_SP}$`; do
		_echoI "backup ${path} to ${path}.${_SDATE}"
		_evalr zfs rename ${path} ${path}.${_SDATE}
	done
elif [ "${S_STORAGE_DRIVER}" = btrfs ]; then
	for path in `ls ${S_HOST_PATH_SP}`; do
		_echoI "backup ${path} to ${path}.${_SDATE}"
		_evalr mv ${S_HOST_PATH_SP}/${path} ${S_HOST_PATH_SP}/${path}.${_SDATE}
	done
else
	_exite "This part have to be implemented"
fi


########################  INIT

_echoT "----------  lxd init"

if [ "${S_STORAGE_DRIVER}" = zfs ]; then
	_echoI "Use this settings:"
	_echoW "- Create a new ZFS pool ?: no"
	_echoW "- Name of the existing ZFS pool or dataset: ${_ZFS_ROOT}${S_HOST_PATH_SP}/default"
elif [ "${S_STORAGE_DRIVER}" = btrfs ]; then
	_echoI "Use this settings:"
	_echoW "- Would you like to create a new btrfs subvolume under /var/snap/lxd/common/lxd?: no"
	_echoW "- Create a new BTRFS pool?: no"
	_echoW "- Name of the existing BTRFS pool or dataset: ${S_HOST_PATH_SP}/default"
else
	_exite "This part have to be implemented"
fi

_evalr lxd init || _exite "unable to initalize lxd"


########################  DNS

str=" ovh home "
if [ "${str/ ${S_SERVER_TYPE} /}" != "${str}" ]; then

	# get : s_inet s_cidr s_base
	eval ${S_HOST_VM_ETH[default]}

	_echoT "----------  dns ovh"

	file=/etc/resolvconf.conf
	_keepcpts ${file}
	if ! grep -q 127.0.0.53 ${file}; then
		sudo sh -c "echo -e 'name_servers=127.0.0.53\nresolv_conf_options=\"edns0 trust-ad\"\n#search_domains=lxd\nsearch_domains_append=lxd' >> ${file}"
	 fi

	_echoT "----------  systemd resolved"

	systemctl is-active systemd-resolved|grep -q ^inactive && _service start systemd-resolved
	systemctl is-enabled systemd-resolved|grep -q ^disabled && _service enable systemd-resolved

	_echoT "----------  dns home"

	service=lxd-dns-${s_inet}
	file=/etc/systemd/system/${service}.service
	sudo sh -c "echo '[Unit]
Description=LXD per-link DNS configuration for ${s_inet}
BindsTo=sys-subsystem-net-devices-${s_inet}.device
After=sys-subsystem-net-devices-${s_inet}.device

[Service]
Type=oneshot
ExecStart=/usr/bin/resolvectl dns ${s_inet} ${s_cidr%/*}
ExecStart=/usr/bin/resolvectl domain ${s_inet} '~lxd'

[Install]
WantedBy=sys-subsystem-net-devices-${s_inet}.device
' > ${file}"

	_evalr systemctl daemon-reload
	_evalr systemctl enable --now ${service}
	_evalr resolvectl status ${s_inet}

	_echoT "----------  nsswitch"

	file=/etc/nsswitch.conf
	line="hosts: files mymachines mdns4_minimal [NOTFOUND=return] dns resolve [!UNAVAIL=return] mdns4 myhostname"
	grep -q ^#hosts ${file} || sudo sed -i "s|^\(hosts:.*\)$|#\1\n${line}|" ${file}


	_echoT "----------  20-rc-manager"

	# load resolvconf.conf
	#file=/etc/NetworkManager/conf.d/20-rc-manager.conf
	#sudo sh -c "echo -e '[main]\nrc-manager=resolvconf' > ${file}"

fi


########################  STORAGE

name="stock"
_echoT "----------  storage ${name}"

if ! [ "`sudo lxc storage list -f json|jq -r '.[] | select(.name == "'${name}'").name'`" ]; then
	if [ "${S_STORAGE_DRIVER}" = zfs ]; then
		_evalr lxc storage create ${name} zfs source=${_ZFS_ROOT}${S_HOST_PATH_SP}/${name}
	elif [ "${S_STORAGE_DRIVER}" = btrfs ]; then
		_evalr lxc storage create ${name} btrfs source=${S_HOST_PATH_SP}/${name}
	else
		_exite "This part have to be implemented"
	fi
fi


########################  NETWORK

_echoT "----------  network 'default'"

# get : s_inet s_cidr s_base
eval ${S_HOST_VM_ETH[default]}

_echoT "----------  network ${s_inet}"

if ! [ "`sudo lxc network list -f json|jq -r '.[] | select(.name == "'${s_inet}'").name'`" ]; then
	_evalr lxc network create ${s_inet}
fi
_evalr lxc network set ${s_inet} ipv4.address=${s_cidr} ipv4.dhcp.ranges=${s_cidr%.*}.${_LXD_DHCP_MIN}-${s_cidr%.*}.${_LXD_DHCP_MAX} ipv4.nat=true dns.mode=managed dns.domain=lxd dns.mode=managed


_echoT "----------  network 'stock'"

# get : s_inet s_cidr s_base
eval ${S_HOST_VM_ETH[stock]}

_echoT "----------  network ${s_inet}"

if ! [ "`sudo lxc network list -f json|jq -r '.[] | select(.name == "'${s_inet}'").name'`" ]; then
	_evalr lxc network create "${s_inet}"
fi
_evalr lxc network set ${s_inet} ipv4.address=${s_cidr} ipv4.dhcp.ranges=${s_cidr%.*}.${_LXD_DHCP_MIN}-${s_cidr%.*}.${_LXD_DHCP_MAX} ipv4.nat=true dns.mode=managed dns.domain=lxd1 dns.mode=managed


########################  PROFILE

profile="stock"
_echoT "----------  profiles ${profile}"

_evalr lxc profile list -f csv|grep -q "^${profile}," && _evalr lxc profile rename ${profile} ${profile}.${_SDATE}
_evalr lxc profile create ${profile}
_evalr lxc profile device add ${profile} root disk pool=stock path=/
_evalr lxc network attach-profile lxdbr1 ${profile} eth0


########################  RSYSLOG

_echoT "----------  rsyslog install"
_eval yay --noconfirm -S rsyslog

_echoT "----------  rsyslog path"
for path in /etc/rsyslog.d /var/spool/rsyslog; do
	[ -d ${path} ] || _evalr mkdir ${path}
done

_echoT "----------  rsyslog conf"

file=/etc/rsyslog.conf
_keepcpts ${file}

# udp
if [ "${S_RSYSLOG_PTC}" = udp ]; then
	str="\$ModLoad immark\n\$ModLoad imudp  # provides udp logging support\n\$UDPServerRun 514"
# tcp
elif [ "${S_RSYSLOG_PTC}" = tcp ]; then
	str="\$ModLoad immark\n\$ModLoad imtcp  # provides udp logging support\n\$InputTCPServerRun 514"
fi
_evalr "sed -i 's|^\(\$ModLoad imklog.*\)$|\1\n${str}|' ${file}"


_echoT "----------  rsyslog cron"
file=/etc/rsyslog.d/${file_rsyslog_cron##*/}
_evalr cp -a ${file_rsyslog_cron} ${file}
_var_replace ${file} rsyslog


_echoT "----------  rsyslog client-auth"
file=/etc/rsyslog.d/${file_rsyslog_client_auth##*/}
_evalr cp -a ${file_rsyslog_client_auth} ${file}
_var_replace ${file} rsyslog


#TODO add rsyslog mail
<<KEEP
_echoT "----------  rsyslog mail conf"
file="/etc/rsyslog.d/50-default.conf"
# stop mail logs for syslog
! grep -q "mail\.\*\s*stop" "${file}" && sed -i '/^mail\.err/ amail.*              stop' "${file}"
KEEP


_echoT "----------  rsyslog restart"
_service restart rsyslog


_echoT "----------  lxc container"
echoI "To install and configure container use:"
_echoI "$(ls -1 ${S_PATH_INSTALL/-desktop/}/lxd-*)"


########################  REBOOT

_echoT "---------- reboot"
_echoI "You have to reboot before continuing"


########################  END

_echoT "===================== ${_PART} end"
_partadd "${_PART}" "${S_FILE_INSTALL_DONE}"


<<KEEP
########################  INSTALL

_echoT "------------------ install snap jq"

_evalr pacman -S snapd jq
_evalr systemctl enable --now snapd.socket
_evalr ln -s /var/lib/snapd/snap /snap

_echoT "------------------ install lxd"

_evalr snap install lxd

########################  RIGHTS

path="/var/snap/lxd/common/lxd"
_echoT "----------  link ${path} to /lxd"

link="/lxd"
[ -h ${link} ] || _evalr ln -s ${path} ${link}

path="${S_HOST_PATH_SHARE}"
_echoT "----------  rights ${path}"

if [ "${S_STORAGE_DRIVER}" = zfs ]; then
	_evalr setfacl -Rm u:1000000:rwx "${path}"
	_evalr setfacl -Rm d:u:1000000:rwx "${path}"
elif [ "${S_STORAGE_DRIVER}" = btrfs ]; then
	_evalr setfacl -Rm u:100000:rwx "${path}"
	_evalr setfacl -Rm d:u:100000:rwx "${path}"
else
	_exite "This part have to be implemented"
fi

########################  RIGHTS

path="/var/snap/lxd/common/lxd"
_echoT "----------  link ${path} to /lxd"

KEEP


