#!/bin/bash
#
# write by Aguy

_echoT "\n==========================================  ${S_RELEASE_NAME}-${_PART}"

grep -q "^# ${_PART}" "${S_FILE_INSTALL_CONF}" || echo -e "# ${_PART}" >> "${S_FILE_INSTALL_CONF}"

########################  REQUIRED

path_install_server=/home/shared/dev/install/conf
file_rsyslog_cron=${path_install_server}/rsyslog/cron.conf
file_rsyslog_client_auth=${path_install_server}/rsyslog/client-auth.conf
file_logrotate_server=${path_install_server}/logrotate/client-server

_echoT "----------  required files"

_require ${file_rsyslog_cron} ${file_rsyslog_client_auth} ${file_logrotate_server}


########################  DATA

_echoT "----------  data"

[ -z ${_LXD_DHCP_MIN+x} ] && anstmp="20" && _askno "Give minimal range IP for DHCP container (${anstmp})" && _LXD_DHCP_MIN="${_ANSWER:-$anstmp}" && _confset _LXD_DHCP_MIN "${_LXD_DHCP_MIN}"
[ -z ${_LXD_DHCP_MAX+x} ] && anstmp="254" && _askno "Give maximal range IP for DHCP container (${anstmp})" && _LXD_DHCP_MAX="${_ANSWER:-$anstmp}" && _confset _LXD_DHCP_MAX "${_LXD_DHCP_MAX}"

# root path of lxd
_LXD_PATH_ROOT=/var/snap/lxd/common/lxd && _confset _LXD_PATH_ROOT "${_LXD_PATH_ROOT}"
# root path of storage pools for
_LXD_PATH_SP=storage-pools && _confset _LXD_PATH_SP "${_LXD_PATH_SP}"
# path for containers
_LXD_PATH_CT=containers && _confset _LXD_PATH_CT "${_LXD_PATH_CT}"
# path for containers images
_LXD_PATH_IMAGE=images && _confset _LXD_PATH_IMAGE "${_LXD_PATH_IMAGE}"
# path for containers snapshots
_LXD_PATH_SNAPSHOT=snapshots && _confset _LXD_PATH_SNAPSHOT "${_LXD_PATH_SNAPSHOT}"
# path for export
_LXD_PATH_EXPORT=export && _confset _LXD_PATH_EXPORT "${_LXD_PATH_EXPORT}"
# port for remote connection
_LXD_PORT=8443 && _confset _LXD_PORT "${_LXD_PORT}"


########################  PATH

paths="${S_HOST_PATH} ${S_HOST_PATH_SP} ${S_HOST_PATH_SHARE} ${S_HOST_PATH_LOG} ${S_HOST_PATH_SAVE}"
_echoT "----------  create ${paths}"
for path in ${paths}; do
	[ -d "${path}" ] || _evalqr mkdir -p ${path}
done

########################  INSTALL

_echoT "----------  install"

_evalr apt install -y jq acl # criu lxd-tools

_echoT "----------  snap"

if snap list|grep -q '^lxd '; then
	_evalr snap remove lxd
	_evalr snap refresh
	if snap list|grep -q '^core18 '; then
		_evalr snap install core20
	fi
fi
_evalr snap refresh
_evalr snap install lxd

_echoT "----------  add user"
_evalr usermod -a -G lxd ${USER}


########################  RIGHTS

_echoT "----------  link ${_LXD_PATH_ROOT} to /lxd"

link=/lxd
[ -h ${link} ] || _evalr ln -s ${_LXD_PATH_ROOT} ${link}

path=${S_HOST_PATH_SHARE}
_echoT "----------  rights ${path}"
id=1000000
_evalr setfacl -Rm u:${id}:rwx ${path}
_evalr setfacl -Rm d:u:${id}:rwx ${path}
_evalr chown ${id}:${id} -R "${path}"


########################  CLEAN STORAGE

if [ "${S_STORAGE_DRIVER}" = zfs ]; then
	for path in `_evalr zfs list -d 1 -o name -H ${_ZFS_ROOT}${S_HOST_PATH_SP}|grep -v ^${_ZFS_ROOT}${S_HOST_PATH_SP}$`; do
		_echoI "backup ${path} to ${path}.${_SDATE}"
		_evalr zfs rename ${path} ${path}.${_SDATE}
	done
elif [ "${S_STORAGE_DRIVER}" = btrfs ]; then
	for path in `ls ${S_HOST_PATH_SP}`; do
		_echoI "backup ${path} to ${path}.${_SDATE}"
		_evalr mv ${S_HOST_PATH_SP}/${path} ${S_HOST_PATH_SP}/${path}.${_SDATE}
	done
else
	_exite "This part have to be implemented"
fi


########################  INIT

_echoT "----------  lxd init"

if [ "${S_STORAGE_DRIVER}" = zfs ]; then
	_echoI "Use this settings:"
	_echoW "- Create a new ZFS pool ?: no"
	_echoW "- Name of the existing ZFS pool or dataset: ${_ZFS_ROOT}${S_HOST_PATH_SP}/default"
elif [ "${S_STORAGE_DRIVER}" = btrfs ]; then
	_echoI "Use this settings:"
	_echoW "- Would you like to create a new btrfs subvolume under /var/snap/lxd/common/lxd?: no"
	_echoW "- Create a new BTRFS pool?: no"
	_echoW "- Name of the existing BTRFS pool or dataset: ${S_HOST_PATH_SP}/default"
else
	_exite "This part have to be implemented"
fi

_evalr lxd init || _exite "unable to initalize lxd"


########################  DNS

str=" ovh home "
if [ "${str/ ${S_SERVER_TYPE} /}" != "${str}" ]; then

	# get : s_inet s_cidr s_base
	eval ${S_HOST_VM_ETH[default]}

	_echoT "----------  dns ovh"

	file=/etc/resolv.conf
	_keepcpts ${file}
	if ! grep -q ${s_inet} ${file}; then
		_evalr "sed -i 's|^|#|' ${file}"
		sudo sh -c "echo 'nameserver 127.0.0.53\noptions edns0 trust-ad\nsearch lxd' > ${file}"
	 fi

	_echoT "----------  dns home"

	service=lxd-dns-${s_inet}
	file=/etc/systemd/system/${service}.service
	sudo sh -c "echo '[Unit]
Description=LXD per-link DNS configuration for ${s_inet}
BindsTo=sys-subsystem-net-devices-${s_inet}.device
After=sys-subsystem-net-devices-${s_inet}.device

[Service]
Type=oneshot
ExecStart=/usr/bin/resolvectl dns ${s_inet} ${s_cidr%/*}
ExecStart=/usr/bin/resolvectl domain ${s_inet} '~lxd'

[Install]
WantedBy=sys-subsystem-net-devices-${s_inet}.device
' > ${file}"

	_evalr systemctl daemon-reload
	_evalr systemctl enable --now ${service}
	_evalr resolvectl status ${s_inet}

fi


########################  STORAGE

name="stock"
_echoT "----------  storage ${name}"

if ! [ "`lxc storage list -f json|jq -r '.[] | select(.name == "'${name}'").name'`" ]; then
	if [ "${S_STORAGE_DRIVER}" = zfs ]; then
		_eval lxc storage create ${name} zfs source=${_ZFS_ROOT}${S_HOST_PATH_SP}/${name}
	elif [ "${S_STORAGE_DRIVER}" = btrfs ]; then
		_eval lxc storage create ${name} btrfs source=${S_HOST_PATH_SP}/${name}
	else
		_exite "This part have to be implemented"
	fi
fi


########################  NETWORK

_echoT "----------  network 'default'"

# get : s_inet s_cidr s_base
eval ${S_HOST_VM_ETH[default]}

_echoT "----------  network ${s_inet}"

if ! [ "`lxc network list -f json|jq -r '.[] | select(.name == "'${s_inet}'").name'`" ]; then
	_eval lxc network create ${s_inet}
fi
_eval lxc network set ${s_inet} ipv4.address=${s_cidr} ipv4.dhcp.ranges=${s_cidr%.*}.${_LXD_DHCP_MIN}-${s_cidr%.*}.${_LXD_DHCP_MAX} ipv4.nat=true dns.mode=managed dns.domain=lxd dns.mode=managed


_echoT "----------  network 'stock'"

# get : s_inet s_cidr s_base
eval ${S_HOST_VM_ETH[stock]}

_echoT "----------  network ${s_inet}"

if ! [ "`lxc network list -f json|jq -r '.[] | select(.name == "'${s_inet}'").name'`" ]; then
	_eval lxc network create "${s_inet}"
fi
_eval lxc network set ${s_inet} ipv4.address=${s_cidr} ipv4.dhcp.ranges=${s_cidr%.*}.${_LXD_DHCP_MIN}-${s_cidr%.*}.${_LXD_DHCP_MAX} ipv4.nat=true dns.mode=managed dns.domain=lxd1 dns.mode=managed


########################  PROFILE

profile="stock"
_echoT "----------  profiles ${profile}"

lxc profile list -f csv|grep -q "^${profile}," && _eval lxc profile rename ${profile} ${profile}.${_SDATE}
_eval lxc profile create ${profile}
_eval lxc profile device add ${profile} root disk pool=stock path=/
_eval lxc network attach-profile lxdbr1 ${profile} eth0


_echoT "----------  lxc container"

_echoI "To install and configure container use:"
_echoI "$(ls -1 ${S_PATH_INSTALL/-desktop/}/lxd-*)"


########################  RSYSLOG

_echoT "----------  rsyslog conf"

file=/etc/rsyslog.conf
_keepcpts ${file}

# udp
if [ "${S_RSYSLOG_PTC}" = udp ]; then
	_evalr "sed -i 's|^#\?\(module(load=\"imudp.*\)$|\1|' ${file}"
	_evalr "sed -i 's|^#\?\(input(type=\"imudp\"\).*$|\1 port=\"${S_RSYSLOG_PORT}\")|' ${file}"
# tcp
elif [ "${S_RSYSLOG_PTC}" = tcp ]; then
	_evalr "sed -i 's|^#\?\(module(load=\"imtcp.*\)$|\1|' ${file}"
	_evalr "sed -i 's|^#\?\(input(type=\"imtcp\"\).*$|\1 port=\"${S_RSYSLOG_PORT}\")|' ${file}"
fi


_echoT "----------  rsyslog cron"
file=/etc/rsyslog.d/30-${file_rsyslog_cron##*/}
_evalr cp -a ${file_rsyslog_cron} ${file}
_var_replace ${file} rsyslog


_echoT "----------  rsyslog client-auth"
file=/etc/rsyslog.d/32-${file_rsyslog_client_auth##*/}
_evalr cp -a ${file_rsyslog_client_auth} ${file}
_var_replace ${file} rsyslog


#TODO add rsyslog mail
<<KEEP
_echoT "----------  rsyslog mail conf"
file="/etc/rsyslog.d/50-default.conf"
# stop mail logs for syslog
! grep -q "mail\.\*\s*stop" "${file}" && sed -i '/^mail\.err/ amail.*              stop' "${file}"
KEEP


_echoT "----------  rsyslog restart"
_service restart rsyslog


########################  REBOOT

_echoT "---------- reboot"
_echoI "You have to reboot before continuing"


########################  END

_echoT "===================== ${_PART} end"
_partadd "${_PART}" "${S_FILE_INSTALL_DONE}"
